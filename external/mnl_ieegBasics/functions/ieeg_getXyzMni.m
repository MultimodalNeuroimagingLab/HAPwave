%% This function transforms a set of input coordinates (e.g. for electrodes) from native space to MNI space,
% according to a MNI forward deformation images generated by SPM12 segmentation.
% "Electrode" refers to xyz coordinate in the code, but the function is applicable to any set of nx3 coordinates (vertices, etc.)
%
%   This function applies a robust method of transforming the coordinates:
%       1. The full set of coordinates is split into multiple subsets, in which the coordinates are at least <minDist>
%           far apart from each other.
%       2. Each subset is separately converted to brain volumes, and then each coordinate is smoothed into a 3x3x3 cube
%           so that the MNI transformation is unlikely to drop any coordinates
%       3. The SPM MNI transformation is performed on each separate electrode image
%       4. The MNI coordinates are obtained from the MNI images as the mean position of each smoothed cube, and then
%           all MNI coordinates are merged back together as output.
%
%   Requires helper functions getSequentialDir.m and trimElSet.m
%
%   xyzMni = getXyzMni(xyz, image, warpPath, rootdir, minDist);
%   xyzMni = getXyzMni(xyz, image, warpPath, rootdir);
%       xyz =       nx3 double, native coordinates to transform, where each row is a separate coordinate and columns are [x, y, z]. 
%       niImage =   1x1 nifti, image of the brain volume where the native <xyz> coordinates reside. This image is needed
%                       to get 1) the dimensions of the brain volume (image.dim) and 2) the transformation matrix
%                       (image.mat) to go from voxels <-> position
%                   The path/y_niImage.nii deformation field should
%                       exist.
%       rootdir =   1x1 str, directory to save & load electrode nifti images. A new folder will be created within <rootdir>
%       minDist =   1x1 double (optional), minimum distance (mm) allowed between coordinates in each coordinate subset.
%                       Default = 8. Mathematically, <minDist> should be greater than 2*sqrt(3)*1.5 = 5.2 to because
%                       that is the center-to-center distance in native space between 2 smoothed cubes that touch corner-to-corner
%
%   returns:
%       xyzMni =    nx3 double, coordinates transformed to MNI space. Rows and columns match input xyz structure. Nans
%                       in input xyz rows are propagated to the correct rows.
%
%   HH 2021
%
function xyzMni = ieeg_getXyzMni(xyz, niImageName, rootdir, minDist)
    
    if ~exist('spm_vol.m','file')
        error('make sure spm is in your path')
    else
        niImage = spm_vol(niImageName);
    end   

    if nargin < 4, minDist = 8; end
    if minDist <= 2*sqrt(3)*1.5, warning('low minDist specified may result in inaccurate smoothing of coordinates'); end
    
    outdir = getSeqDir(rootdir, 'xyzImgs'); % where electrode nifti images are saved to & read from
    mkdir(outdir);
    
    % Remove nan coordinates, but track where (non)nan elements are to repropagate at the end
    origLength = size(xyz, 1);
    nonNanBool = ~any(isnan(xyz), 2);
    xyz(any(isnan(xyz), 2),:) = [];
    fprintf('\nGetting MNI coords for %d entries; %d nans.\nUsing minDist = %d.\nSaving images to:\n%s\n\n', size(xyz, 1), sum(~nonNanBool), minDist, outdir);

    %% Separate coordinates into multiple subsets so that all electrodes are at least <minDist> apart in each subset
    % Shoutout to SC for helping to brainstorm this method
    
    xyzStruct = struct(); % Stores the index, positions (native & MNI) for each electrode subset
    
    dists = squareform(pdist(xyz)); % pairwise distance between all electrodes
    remainingElecs = 1:size(xyz, 1); % tracks which electrodes have not been assigned to a subset yet
    counter = 1;
    while ~isempty(remainingElecs)
        
        idx = ieeg_trimElSet(remainingElecs, dists, minDist); % array of electrode indices assigned to current subset
        xyzStruct(counter).idx = idx;
        xyzStruct(counter).xyz = xyz(idx, :);
        remainingElecs = setdiff(remainingElecs, idx);
        
        counter = counter + 1;
    end
    fprintf('Created %d coordinate subsets\n', length(xyzStruct));
    
    %% Create smoothed nifti images from each electrode subset
    
    disp('Saving native coordinate nifti images...');
    dataOut = niImage; % use input image as template for electrode image outputs
    for ii = 1:length(xyzStruct)
        
        idx = xyzStruct(ii).idx; % electrode indices in current set
        vol = zeros(niImage.dim); % volume to put electrodes in
        
        % transform xyz positions to (nearest) voxel indices
        xyz_ind = round([xyzStruct(ii).xyz ones(length(idx), 1)] * inv(niImage.mat')); 
        xyz_ind(:, 4) = [];
        for jj = 1:length(idx)
            vol(xyz_ind(jj, 1), xyz_ind(jj, 2), xyz_ind(jj, 3)) = idx(jj); % assign electrode index as "identity" of voxel
        end
        
        % smooth electrodes to 3x3x3 cube so MNI transformation doesn't drop any. 27x factor is to preserve weight after smoothing
        vol = 27*smooth3(vol, 'box', [3, 3, 3]);
        
        dataOut.fname = fullfile(outdir, sprintf('elVol_%d.nii', ii));
        spm_write_vol(dataOut, vol);
        
    end
    
    %% Call SPM12 to transform electrode images to MNI space
    
    disp('(SPM) Transforming native electrode images to MNI space...');
    spm('defaults', 'fmri');
    
    % SPM requires the forward deform file path to be given without the 'y_' prefix, which is complete
    % baloney. So we have to do this convoluted step of removing 2 characters from the file name. Dumb.
    % d = dir(deformPath); deformPathEdited = fullfile(d.folder, d.name(3:end));
    deformPathEdited = niImageName;
    
    for ii = 1:length(xyzStruct)
        
        img = fullfile(outdir, sprintf('elVol_%d.nii', ii)); % nifti image to transform to MNI

        flags.preserve  = 0;
        flags.bb        = [-90 -120 -60; 90 90 100]; % check boundaries of MNI brain
        flags.vox       = [1 1 1]; % output voxel size
        flags.interp    = 0; % nearest neighbor interpolation
        flags.wrap      = [0 0 0];
        flags.prefix    = 'mni_';

        job.subj.vol{1} = deformPathEdited; % forward deformation = "y_warpPathEdited";
        job.subj.resample{1} = img;
        job.woptions=flags;

        spm_run_norm(job); % output images 'mni_inputName' are saved in same directory as input images
        
    end
    
    %% Obtain MNI-space coordinate subsets from MNI-transformed electrode images
    
    disp('Retrieving MNI coordinates from images...');
    for ii = 1:length(xyzStruct)
        
        elimg = spm_vol(fullfile(outdir, sprintf('mni_elVol_%d.nii', ii)));
        elvol = spm_read_vols(elimg);
        
        elvol(isnan(elvol)) = 0; % remove NaNs
        
        idxes = unique(elvol); % retrieve electrode indices, in ascending order
        idxes(idxes == 0) = [];
        
        % Check that the number of indices stayed the same after MNI transform AND that the indices match (to a tolerance)
        assert(length(idxes) == length(xyzStruct(ii).idx), 'Different number of electrodes in set #%d after MNI warp', ii);
        assert(sum(idxes - xyzStruct(ii).idx(:)) < 1, 'MNI XYZ indices do not match original indices in set %d', ii);
        
        xyzStruct(ii).xyzMNI = [];
        for jj = 1:length(idxes)
            
            currEl = []; % all voxels with values that match the current electrod index
            [currEl(:, 1), currEl(:, 2), currEl(:, 3)] = ind2sub(size(elvol), find(elvol == idxes(jj)));
            currElMean = mean(currEl, 1); % mean position of electrode in MNI voxels
            currElMeanPos = [currElMean, 1] * elimg.mat'; currElMeanPos(4) = []; % transform MNI voxel -> MNI position
            
            xyzStruct(ii).xyzMNI = [xyzStruct(ii).xyzMNI; currElMeanPos];
            
        end
    end
    
    %% Merge coordinates from all subsets
    
    disp('Merging MNI coordinate subsets together...');
    xyzMniNoNan = zeros(size(xyz));
    for ii = 1:length(xyzStruct)
        xyzMniNoNan(xyzStruct(ii).idx, :) = xyzStruct(ii).xyzMNI;
    end
    
    % Display the average % change in pairwise coordinate distances (as a marker of coordinate structure preservation)
    newdists = squareform(pdist(xyzMniNoNan));
    distChgs = (newdists - dists)./dists;
    avgChg = mean(distChgs, 'all', 'omitnan');
    stdChg = std(distChgs, 0, 'all', 'omitnan');
    fprintf('Mean & SD percent change in pair-wise coordinate distances = %.1f +/- %.1f (%%)\n', 100*avgChg, 100*stdChg);
    
    % Repropagate nans so the output coordinate rows match 1-to-1 with input coordinates
    xyzMni = NaN(origLength, 3);
    xyzMni(nonNanBool, :) = xyzMniNoNan;
    
end

%% Returns directory paths named "pattern_1", "pattern_2" ... based on their sequential existence in a root directory
%
%   outdir = getSequentialDir(rootdir, pattern)
%       rootdir =       str, path to root directory where the sequential directories are located
%       pattern =       str, the string before the underscore for directory naming (pattern_1, pattern_2 ...)
%
%   returns
%       outdir =        str, path to the next sequential directory named pattern_n in the root directory
%
%   HH 2021
%
function outdir = getSeqDir(rootdir, pattern)

    % Find all other directories located in rootdir with the same pattern_
    prevdirs = dir(fullfile(rootdir, sprintf('%s_*', pattern)));
    
    if isempty(prevdirs)
        outdir = fullfile(rootdir, sprintf('%s_1', pattern));
    else
        % Return outdir as 1 + the last currently existing directory number
        elems = split(prevdirs(end).name, '_');
        outdir = fullfile(rootdir, sprintf('%s_%d', pattern, str2double(elems{end}) + 1));
    end
end
